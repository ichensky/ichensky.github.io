# SOLID

**SOLID** is a mnemonic acronym for five design principles intended *to make* **object-oriented designs** more understandable, flexible, and **maintainable**.

The principles are a subset of many principles first introduced by [Robert C. Martin](https://sites.google.com/site/unclebobconsultingllc) in 2000th in the paper [Design Principles and Design Patterns](https://web.archive.org/web/20150906155800/http://www.objectmentor.com/resources/articles/Principles_and_Patterns.pdf)

* **Single Responsibility Principle**. 
  [srp.pdf](https://web.archive.org/web/20150202200348/http://www.objectmentor.com/resources/articles/srp.pdf)
  
  > There should never be more than one reason for a class to change.

  Update 2018. "Clean architecture: a craftsman's guide to software structure and design":
  > A module should be responsible to one, and only one, actor.

* **Open-Closed Principle**. 
    
    Original [ocp](https://web.archive.org/web/20150905081105/http://www.objectmentor.com/resources/articles/ocp.pdf)

    > Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification. 

    Update [2014](https://blog.cleancoder.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html)

    > You should be able to extend the behavior of a system without having to modify that system. 

* **Liskov Substitution Principle**. 
  [lcp](https://web.archive.org/web/20150905081111/http://www.objectmentor.com/resources/articles/lsp.pdf)

    > Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.

* **Interface Segregation Principle**.
   [isp](https://web.archive.org/web/20150905081110/http://www.objectmentor.com/resources/articles/isp.pdf)

    > Clients should not be forced to depend upon interfaces that they do not use.

* **Dependency Inversion Principle**. 
  [dip](https://web.archive.org/web/20150905081103/http://www.objectmentor.com/resources/articles/dip.pdf)

  > A. High-level modules should not depend upon low-level modules. Both should depend upon abstractions.

  > B. Abstractions should not depend upon details. Details should depend upon abstractions.

 Â  

